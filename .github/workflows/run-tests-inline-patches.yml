name: Run tests with inline patches

on:
  workflow_dispatch:
    inputs:
      commit_sha:
        required: true
        type: string
      patches_json_b64:
        required: true
        type: string
      test_cmd:
        required: true
        type: string
      callback_url:
        required: true
        type: string
      run_id:
        required: true
        type: string

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Decode patches
        shell: bash
        env:
          PATCHES_JSON_B64: ${{ inputs.patches_json_b64 }}
        run: |
          set -euo pipefail
          mkdir -p /tmp/patches /tmp/logs
          export PATCHES_JSON="$(printf '%s' "$PATCHES_JSON_B64" | base64 -d)"

          cat > /tmp/decode.py <<'PY'
          import json, base64, os, pathlib
          arr = json.loads(os.environ["PATCHES_JSON"])
          out = pathlib.Path("/tmp/patches"); out.mkdir(parents=True, exist_ok=True)
          (out / "test.patch").write_bytes(base64.b64decode(arr[0]))
          for i,p in enumerate(arr[1:],1):
              (out / f"golden_{i:03d}.patch").write_bytes(base64.b64decode(p))
          PY
          python3 /tmp/decode.py

      - name: Check1 – golden only
        id: check1
        shell: bash
        run: |
          set +e; set -o pipefail
          git checkout --force "${{ inputs.commit_sha }}"
          git reset --hard; git clean -fdx

          APPLY_OK=true
          for p in /tmp/patches/golden_*.patch; do
            git apply "$p" 2>&1 | tee -a /tmp/logs/c1_apply.log || { APPLY_OK=false; echo "golden_exit=100" >>$GITHUB_OUTPUT; break; }
          done

          if [ "$APPLY_OK" = true ]; then
            bash -lc "${{ inputs.test_cmd }}" 2>&1 | tee /tmp/logs/c1_test.log
            echo "golden_exit=${PIPESTATUS[0]}" >>$GITHUB_OUTPUT
          fi

          echo "golden_apply_ok=$APPLY_OK" >>$GITHUB_OUTPUT
          exit 0

      - name: Check2 – golden + test
        id: check2
        shell: bash
        run: |
          set +e; set -o pipefail
          git checkout --force "${{ inputs.commit_sha }}"
          git reset --hard; git clean -fdx

          APPLY_OK=true
          for p in /tmp/patches/golden_*.patch; do
            git apply "$p" 2>&1 | tee -a /tmp/logs/c2_apply.log || { APPLY_OK=false; echo "combined_exit=100" >>$GITHUB_OUTPUT; break; }
          done

          if [ "$APPLY_OK" = true ]; then
            git apply /tmp/patches/test.patch 2>&1 | tee -a /tmp/logs/c2_apply.log || { APPLY_OK=false; echo "combined_exit=101" >>$GITHUB_OUTPUT; }
          fi

          if [ "$APPLY_OK" = true ]; then
            bash -lc "${{ inputs.test_cmd }}" 2>&1 | tee /tmp/logs/c2_test.log
            echo "combined_exit=${PIPESTATUS[0]}" >>$GITHUB_OUTPUT
          fi

          echo "combined_apply_ok=$APPLY_OK" >>$GITHUB_OUTPUT
          exit 0

      - name: Callback to n8n
        if: always()
        shell: bash
        env:
          CALLBACK_URL: ${{ inputs.callback_url }}
          RUN_ID: ${{ inputs.run_id }}
          C1_APPLY_OK: ${{ steps.check1.outputs.golden_apply_ok }}
          C1_EXIT: ${{ steps.check1.outputs.golden_exit }}
          C2_APPLY_OK: ${{ steps.check2.outputs.combined_apply_ok }}
          C2_EXIT: ${{ steps.check2.outputs.combined_exit }}
        run: |
          set -euo pipefail
          tailb(){ [ -f "$1" ] && tail -c 900000 "$1" | base64 -w0 || echo ""; }

          C1_B64="$(tailb /tmp/logs/c1_test.log)"
          C2_B64="$(tailb /tmp/logs/c2_test.log)"

          export C1_B64 C2_B64

          python3 - <<'PY' | curl -sS -X POST "$CALLBACK_URL" -H "Content-Type: application/json" -d @-
          import json, os

          def to_bool(v):
              return str(v).lower() in ("1","true","yes","on")

          payload = {
            "run_id": os.environ["RUN_ID"],
            "repo": os.environ["GITHUB_REPOSITORY"],
            "github_run": os.environ["GITHUB_RUN_ID"],
            "commit": "${{ inputs.commit_sha }}",
            "check1_exit": int(os.environ.get("C1_EXIT","100")),
            "check1_apply_ok": to_bool(os.environ.get("C1_APPLY_OK")),
            "check1_log_b64": os.environ.get("C1_B64",""),
            "check2_exit": int(os.environ.get("C2_EXIT","100")),
            "check2_apply_ok": to_bool(os.environ.get("C2_APPLY_OK")),
            "check2_log_b64": os.environ.get("C2_B64","")
          }

          print(json.dumps(payload))
          PY
          true
